/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module Clash_TinyTapeout_EthernetMac_TopEntity_topEntity_asyncFIFOSynchronizer
    ( // Inputs
      input  eta1 // clock
    , input  eta2 // clock
    , input  eta3 // reset
    , input  eta4 // reset
    , input  eta7
    , input [19:0] eta8

      // Outputs
    , output wire [20:0] result
    );
  wire [37:0] c$case_scrut;
  reg [18:0] c$app_arg;
  wire [18:0] val;
  reg [3:0] c$app_arg_0;
  wire [3:0] addr;
  wire [3:0] addr_0;
  reg  c$app_arg_1;
  reg  c$app_arg_2;
  reg [18:0] c$app_arg_3;
  wire [18:0] val_0;
  reg [3:0] c$app_arg_4;
  wire [3:0] addr_1;
  wire [3:0] addr_2;
  reg  c$app_arg_5;
  reg  c$app_arg_6;
  wire [24:0] t;
  wire [24:0] result_0;
  wire  b;
  wire [18:0] ds1;
  wire [18:0] a1;
  wire  wfull;
  wire [0:0] \c$bin'_app_arg ;
  wire [9:0] result_1;
  reg [10:0] rPtr0_ds2;
  wire [4:0] bin;
  wire [4:0] ptr;
  wire  flag;
  wire [4:0] \bin' ;
  wire [4:0] \ptr' ;
  reg [4:0] wPtr2_result;
  wire [4:0] i1;
  reg [4:0] wPtr1_result;
  wire [9:0] result_2;
  wire [4:0] ptr_0;
  wire [4:0] \ptr'_0 ;
  wire [4:0] \bin'_0 ;
  wire [4:0] bin_0;
  wire [0:0] \c$bin'_app_arg_0 ;
  wire  flag_0;
  reg [10:0] wPtr0_eta9;
  wire [4:0] c$ds_app_arg;
  wire  c$ds1_app_arg;
  reg [4:0] rPtr2_result;
  wire [4:0] i1_0;
  reg [4:0] rPtr1_result;

  assign result = {c$case_scrut[37:19],
                   result_1[9:9],   wfull};

  Clash_TinyTapeout_EthernetMac_TopEntity_topEntity_trueDualPortBlockRamWrapper Clash_TinyTapeout_EthernetMac_TopEntity_topEntity_trueDualPortBlockRamWrapper_c$case_scrut
    ( .result (c$case_scrut)
    , .clkA (eta2)
    , .enA (c$app_arg_6)
    , .weA (c$app_arg_5)
    , .addrA (c$app_arg_4)
    , .datA (c$app_arg_3)
    , .clkB (eta1)
    , .enB (c$app_arg_2)
    , .weB (c$app_arg_1)
    , .addrB (c$app_arg_0)
    , .datB (c$app_arg) );

  always @(*) begin
    case(result_0[24:23])
      2'b01 : c$app_arg = val;
      default : c$app_arg = {19 {1'bx}};
    endcase
  end

  assign val = result_0[18:0];

  always @(*) begin
    case(result_0[24:23])
      2'b00 : c$app_arg_0 = addr_0;
      2'b01 : c$app_arg_0 = addr;
      default : c$app_arg_0 = {4 {1'bx}};
    endcase
  end

  assign addr = result_0[22:19];

  assign addr_0 = result_0[22:19];

  always @(*) begin
    case(result_0[24:23])
      2'b01 : c$app_arg_1 = 1'b1;
      default : c$app_arg_1 = 1'b0;
    endcase
  end

  always @(*) begin
    case(result_0[24:23])
      2'b10 : c$app_arg_2 = 1'b0;
      default : c$app_arg_2 = 1'b1;
    endcase
  end

  always @(*) begin
    case(t[24:23])
      2'b01 : c$app_arg_3 = val_0;
      default : c$app_arg_3 = {19 {1'bx}};
    endcase
  end

  assign val_0 = t[18:0];

  always @(*) begin
    case(t[24:23])
      2'b00 : c$app_arg_4 = addr_2;
      2'b01 : c$app_arg_4 = addr_1;
      default : c$app_arg_4 = {4 {1'bx}};
    endcase
  end

  assign addr_1 = t[22:19];

  assign addr_2 = t[22:19];

  always @(*) begin
    case(t[24:23])
      2'b01 : c$app_arg_5 = 1'b1;
      default : c$app_arg_5 = 1'b0;
    endcase
  end

  always @(*) begin
    case(t[24:23])
      2'b10 : c$app_arg_6 = 1'b0;
      default : c$app_arg_6 = 1'b1;
    endcase
  end

  assign t = {2'b00,result_1[8:5],19'bxxxxxxxxxxxxxxxxxxx};

  assign result_0 = b ? {2'b01,result_2[8:5],ds1} : {2'b10,23'bxxxxxxxxxxxxxxxxxxxxxxx};

  assign b = (~ wfull) & c$ds1_app_arg;

  assign ds1 = eta8[19:19] ? a1 : ({19 {1'bx}});

  assign a1 = eta8[18:0];

  assign wfull = result_2[9:9];

  assign \c$bin'_app_arg  = (eta7 & (~ flag)) ? 1'b1 : 1'b0;

  assign result_1 = {flag,   \bin' [0+:4],   ptr};

  // register begin
  always @(posedge eta2 ) begin : rPtr0_ds2_register
    if ( ! eta4) begin
      rPtr0_ds2 <= {5'b00000,   5'b00000,   1'b1};
    end else begin
      rPtr0_ds2 <= {\bin' ,   \ptr' ,   \ptr'  == wPtr2_result};
    end
  end
  // register end

  assign bin = rPtr0_ds2[10:6];

  assign ptr = rPtr0_ds2[5:1];

  assign flag = rPtr0_ds2[0:0];

  assign \bin'  = bin + ({4'b0000,(\c$bin'_app_arg )});

  assign \ptr'  = (\bin'  >> 64'sd1) ^ \bin' ;

  // register begin
  always @(posedge eta2 ) begin : wPtr2_result_register
    if ( ! eta4) begin
      wPtr2_result <= 5'b00000;
    end else begin
      wPtr2_result <= wPtr1_result;
    end
  end
  // register end

  assign i1 = result_2[4:0];

  // register begin
  always @(posedge eta2 ) begin : wPtr1_result_register
    if ( ! eta4) begin
      wPtr1_result <= 5'b00000;
    end else begin
      wPtr1_result <= i1;
    end
  end
  // register end

  assign result_2 = {flag_0,   bin_0[0+:4],
                     ptr_0};

  assign ptr_0 = wPtr0_eta9[5:1];

  assign \ptr'_0  = (\bin'_0  >> 64'sd1) ^ \bin'_0 ;

  assign \bin'_0  = bin_0 + ({4'b0000,(\c$bin'_app_arg_0 )});

  assign bin_0 = wPtr0_eta9[10:6];

  assign \c$bin'_app_arg_0  = (c$ds1_app_arg & (~ flag_0)) ? 1'b1 : 1'b0;

  assign flag_0 = wPtr0_eta9[0:0];

  // register begin
  always @(posedge eta1 ) begin : wPtr0_eta9_register
    if ( ! eta3) begin
      wPtr0_eta9 <= {5'b00000,   5'b00000,   1'b0};
    end else begin
      wPtr0_eta9 <= {\bin'_0 ,   \ptr'_0 ,
   \ptr'_0  == ({(~ (c$ds_app_arg[4 : 3])),(c$ds_app_arg[2 : 0])})};
    end
  end
  // register end

  assign c$ds_app_arg = rPtr2_result;

  assign c$ds1_app_arg = eta8[19:19] ? 1'b1 : 1'b0;

  // register begin
  always @(posedge eta1 ) begin : rPtr2_result_register
    if ( ! eta3) begin
      rPtr2_result <= 5'b00000;
    end else begin
      rPtr2_result <= rPtr1_result;
    end
  end
  // register end

  assign i1_0 = result_1[4:0];

  // register begin
  always @(posedge eta1 ) begin : rPtr1_result_register
    if ( ! eta3) begin
      rPtr1_result <= 5'b00000;
    end else begin
      rPtr1_result <= i1_0;
    end
  end
  // register end


endmodule

