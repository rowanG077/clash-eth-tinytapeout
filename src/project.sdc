# Shared constants, copied from  base.sdc
set input_delay_value [ expr $::env(CLOCK_PERIOD) * $::env(IO_PCT) ]
set output_delay_value [ expr $::env(CLOCK_PERIOD) * $::env(IO_PCT) ]
set_max_fanout $::env(MAX_FANOUT_CONSTRAINT) [ current_design ]
set cap_load [ expr $::env(OUTPUT_CAP_LOAD) / 1000.0 ] ;# fF -> pF

# Remove clock net from inputs
set idx [ lsearch [ all_inputs ] "clk" ]
set all_inputs_wo_clk [ lreplace [ all_inputs ] $idx $idx ]
set idx [ lsearch $all_inputs_wo_clk "ui_in\[0\]" ]
set all_inputs_wo_clk [ lreplace $all_inputs_wo_clk $idx $idx ]
set idx [ lsearch $all_inputs_wo_clk "ui_in\[1\]" ]
set all_inputs_wo_clk [ lreplace $all_inputs_wo_clk $idx $idx ]

# Constrain pins to clock

#  clk   clock is generated by the RP2040 chip
create_clock [ get_ports "clk" ]  -name rp2040Clk -period $::env(CLOCK_PERIOD)

#  ui_in[0]   clock is generated by MII phy
create_clock [ get_ports "ui_in\[0\]" ]  -name ethRxClk -period $::env(CLOCK_PERIOD)
set_clock_uncertainty $::env(SYNTH_CLOCK_UNCERTAINTY) [ get_clocks ethRxClk ]
set_clock_transition $::env(SYNTH_CLOCK_TRANSITION) [ get_clocks ethRxClk ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "rst_n" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[2\]" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[3\]" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[4\]" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[5\]" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[6\]" ]
set_input_delay $input_delay_value -clock [ get_clocks ethRxClk ] [ get_ports "ui_in\[7\]" ]

#  ui_in[1]   clock is generated by MII phy
create_clock [ get_ports "ui_in\[1\]" ]  -name ethTxClk -period $::env(CLOCK_PERIOD)
set_clock_uncertainty $::env(SYNTH_CLOCK_UNCERTAINTY) [ get_clocks ethTxClk ]
set_clock_transition $::env(SYNTH_CLOCK_TRANSITION) [ get_clocks ethTxClk ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[0\]" ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[1\]" ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[2\]" ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[3\]" ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[4\]" ]
set_output_delay $output_delay_value -clock [ get_clocks ethTxClk ] [ get_ports "uo_out\[5\]" ]


# rp2040Clk and ethRxClk, ethTxClk  are mesochronous, and they never interact
set_clock_groups -asynchronous -group { rp2040Clk } -group { ethRxClk }
set_clock_groups -asynchronous -group { rp2040Clk } -group { ethTxClk }

# Ensure clocks are asynchronous
set_clock_groups -asynchronous -group { ethRxClk } -group { ethTxClk }

# clock uncertainty from phy
set_clock_transition 0.1500 [ get_clocks ethTxClk ]
set_clock_uncertainty 0.2500 [ get_clocks ethTxClk ]

# Ensure CDC paths are constrained
set_max_delay 0.05 -from ethTxClk -to ethRxClk -ignore_clock_latency;
set_max_delay 0.05 -from ethRxClk -to ethTxClk -ignore_clock_latency;

# Miscellanea
set_driving_cell -lib_cell $::env(SYNTH_DRIVING_CELL) -pin $::env(SYNTH_DRIVING_CELL_PIN) $all_inputs_wo_clk
set_load  $cap_load [ all_outputs ]
set_timing_derate -early [ expr {1-$::env(SYNTH_TIMING_DERATE)} ]
set_timing_derate -late [ expr {1+$::env(SYNTH_TIMING_DERATE)} ]
